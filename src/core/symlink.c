"#include \"../../include/core/symlink.h\"\n#include <stdio.h>\n\n// 创建Junction（目录硬链接）\nBOOL CreateJunction(LPCWSTR linkPath, LPCWSTR targetPath)\n{\n    // 确保目标路径存在\n    if (!PathFileExistsW(targetPath)) {\n        return FALSE;\n    }\n    \n    // 创建Junction\n    HANDLE hLink = CreateFileW(linkPath,\n                               GENERIC_WRITE,\n                               0,\n                               NULL,\n                               OPEN_ALWAYS,\n                               FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,\n                               NULL);\n    \n    if (hLink == INVALID_HANDLE_VALUE) {\n        return FALSE;\n    }\n    \n    // 构建REPARSE_DATA_BUFFER结构\n    USHORT targetLen = (USHORT)(wcslen(targetPath) * sizeof(WCHAR));\n    USHORT bufferLength = REPARSE_DATA_BUFFER_HEADER_SIZE + targetLen + 12;\n    \n    PREPARSE_DATA_BUFFER buffer = (PREPARSE_DATA_BUFFER)malloc(bufferLength);\n    if (!buffer) {\n        CloseHandle(hLink);\n        return FALSE;\n    }\n    \n    ZeroMemory(buffer, bufferLength);\n    buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n    buffer->ReparseDataLength = targetLen + 8;\n    buffer->MountPointReparseBuffer.SubstituteNameLength = targetLen;\n    buffer->MountPointReparseBuffer.SubstituteNameOffset = 0;\n    buffer->MountPointReparseBuffer.PrintNameLength = 0;\n    buffer->MountPointReparseBuffer.PrintNameOffset = targetLen + 2;\n    \n    // 构建路径: \\??\D:\\Path\n    wcscpy_s(buffer->MountPointReparseBuffer.PathBuffer, MAX_PATH, L\"\\\\??\\\\\");\n    wcscat_s(buffer->MountPointReparseBuffer.PathBuffer, MAX_PATH, targetPath);\n    \n    DWORD bytesReturned;\n    BOOL result = DeviceIoControl(hLink,\n                                  FSCTL_SET_REPARSE_POINT,\n                                  buffer,\n                                  bufferLength,\n                                  NULL,\n                                  0,\n                                  &bytesReturned,\n                                  NULL);\n    \n    free(buffer);\n    CloseHandle(hLink);\n    \n    return result;\n}\n\n// 删除Junction\nBOOL DeleteJunction(LPCWSTR linkPath)\n{\n    if (!IsJunction(linkPath)) {\n        return FALSE;\n    }\n    \n    // 清除REPARSE_POINT属性\n    HANDLE hLink = CreateFileW(linkPath,\n                               GENERIC_WRITE,\n                               0,\n                               NULL,\n                               OPEN_EXISTING,\n                               FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,\n                               NULL);\n    \n    if (hLink == INVALID_HANDLE_VALUE) {\n        return FALSE;\n    }\n    \n    REPARSE_DATA_BUFFER buffer = {0};\n    buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;\n    \n    DWORD bytesReturned;\n    BOOL result = DeviceIoControl(hLink,\n                                  FSCTL_DELETE_REPARSE_POINT,\n                                  &buffer,\n                                  REPARSE_DATA_BUFFER_HEADER_SIZE,\n                                  NULL,\n                                  0,\n                                  &bytesReturned,\n                                  NULL);\n    \n    CloseHandle(hLink);\n    \n    if (result) {\n        // 删除目录\n        return RemoveDirectoryW(linkPath);\n    }\n    \n    return FALSE;\n}\n\n// 检查是否是Junction\nBOOL IsJunction(LPCWSTR path)\n{\n    DWORD attrs = GetFileAttributesW(path);\n    \n    if (attrs == INVALID_FILE_ATTRIBUTES) {\n        return FALSE;\n    }\n    \n    return (attrs & FILE_ATTRIBUTE_REPARSE_POINT) != 0;\n}\n\n// 解析Junction目标路径\nBOOL ResolveJunction(LPCWSTR linkPath, WCHAR* targetPath, int pathSize)\n{\n    if (!IsJunction(linkPath)) {\n        return FALSE;\n    }\n    \n    HANDLE hLink = CreateFileW(linkPath,\n                               GENERIC_READ,\n                               0,\n                               NULL,\n                               OPEN_EXISTING,\n                               FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,\n                               NULL);\n    \n    if (hLink == INVALID_HANDLE_VALUE) {\n        return FALSE;\n    }\n    \n    BYTE buffer[MAX_PATH * 2];\n    DWORD bytesReturned;\n    \n    if (DeviceIoControl(hLink,\n                        FSCTL_GET_REPARSE_POINT,\n                        NULL,\n                        0,\n                        buffer,\n                        sizeof(buffer),\n                        &bytesReturned,\n                        NULL)) {\n        \n        PREPARSE_DATA_BUFFER reparseData = (PREPARSE_DATA_BUFFER)buffer;\n        \n        if (reparseData->ReparseTag == IO_REPARSE_TAG_MOUNT_POINT) {\n            WCHAR* pathBuffer = reparseData->MountPointReparseBuffer.PathBuffer;\n            \n            // 跳过 \\??\\ 前缀\n            if (wcsstr(pathBuffer, L\"\\\\??\\\\\") == pathBuffer) {\n                wcscpy_s(targetPath, pathSize, pathBuffer + 4);\n            } else {\n                wcscpy_s(targetPath, pathSize, pathBuffer);\n            }\n            \n            CloseHandle(hLink);\n            return TRUE;\n        }\n    }\n    \n    CloseHandle(hLink);\n    return FALSE;\n}\n\n// 创建符号链接（需要管理员权限）\nBOOL CreateSymlink(LPCWSTR linkPath, LPCWSTR targetPath)\n{\n    // 优先使用Junction，因为更可靠\n    DWORD attrs = GetFileAttributesW(targetPath);\n    if (attrs != INVALID_FILE_ATTRIBUTES && (attrs & FILE_ATTRIBUTE_DIRECTORY)) {\n        return CreateJunction(linkPath, targetPath);\n    }\n    \n    // 文件符号链接\n    return CreateSymbolicLinkW(linkPath, targetPath, 0);\n}\n\n// 删除符号链接\nBOOL DeleteSymlink(LPCWSTR linkPath)\n{\n    if (IsJunction(linkPath)) {\n        return DeleteJunction(linkPath);\n    }\n    \n    return DeleteFileW(linkPath);\n}"